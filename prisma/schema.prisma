generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  directUrl    = env("DIRECT_URL")
  relationMode = "prisma"
}

model User {
  id        String     @id @default(uuid())
  email     String     @unique
  name      String?
  picture   String?
  // A user can be part of multiple teams
  teams     Team[]     @relation("TeamUser")
  roles     TeamRole[]
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
}

model Team {
  id        String     @id @default(uuid())
  name      String
  users     User[]     @relation("TeamUser")
  websites  Website[]
  roles     TeamRole[]
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
}

// Define the TeamRole model, which represents the many-to-many relationship
// between users and teams
model TeamRole {
  id     String @id @default(uuid())
  role   String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String
  teamId String

  @@unique([userId, teamId]) // Ensure that each user can only have one role per team
  @@index([teamId])
}

model Website {
  id      String   @id @default(uuid())
  name    String
  url     String
  token   String   @unique @default(uuid()) // The token is used to authenticate the website
  team    Team     @relation(fields: [teamId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  teamId  String
  events  Event[]
  persons Person[]
  properties Property[]

  scans   Scan[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([teamId])
}

model Scan {
  id         String     @id @default(uuid())
  url      String   

  website    Website  @relation(fields: [websiteId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  websiteId  String

  green           Boolean
  transferSize    Float @default(0.0)
  contentSize     Float @default(0.0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([websiteId])
  @@unique([websiteId, url], name: "domainWebsiteUnique")
}

model Person {
  id         String     @id @default(uuid())
  name       String?
  email      String?
  properties Property[] @relation("PersonProperty") // 1-to-many relation
  events     Event[]    @relation("PersonEvent") // 1-to-many relation
  website    Website    @relation(fields: [websiteId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  websiteId  String
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  @@index([websiteId])
}

model Event {
  id   String @id @default(uuid())
  name String
  type String

  properties Property[] // 1-to-many relation

  person    Person? @relation("PersonEvent", fields: [personId], references: [id], onDelete: Cascade, onUpdate: Cascade) // 0-to-1 relation
  personId  String?
  website   Website @relation(fields: [websiteId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  websiteId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([personId])
  @@index([websiteId])
}

model Property {
  id    String @id @default(uuid())
  key   String
  value String

  event    Event? @relation(fields: [eventId], references: [id], onDelete: Cascade, onUpdate: Cascade) // 0-to-1 relation
  eventId  String?
  person   Person? @relation("PersonProperty", fields: [personId], references: [id], onDelete: Cascade, onUpdate: Cascade) // 0-to-1 relation
  personId String?
  website   Website @relation(fields: [websiteId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  websiteId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([personId, key]) // Ensure that each person can only have one property per key

  @@index([websiteId])
  @@index([personId])
  @@index([eventId])
}
